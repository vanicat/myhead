% Copyright 2010-2011 by RenÃ©e Ahrens
% Copyright 2010-2011 by Olof Frahm
% Copyright 2010-2011 by Jens Kluttig
% Copyright 2010-2011 by Matthias Schulz
% Copyright 2010-2011 by Stephan Schuster
% Copyright 2011 by Jannis Pohlmann
% Copyright 2011 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{The Graph Drawing Engine}

{\noindent {\emph{by Ren\'ee Ahrens, Olof-Joachim Frahm, Jens Kluttig,
  Jannis Pohlmann, Matthias Schulz, Stephan Schuster, and Till Tantau}}}

\label{section-base-graphdrawing}


\begin{pgflibrary}{graphdrawing}
  This package provides the \TeX\ interface to the graph drawing
  engine. Since it uses \LuaTeX, you need at least \LuaTeX\ 0.4 or 
  higher.

  Typically, you will use the \tikzname\ library of the same name
  rather than this library, which internally loads this
  library. Nevertheless, the graph drawing engine can be used
  independently of \tikzname.
\end{pgflibrary}


\ifluatex\relax\else{LuaTeX is required for setting this manual section.}\expandafter\endinput\fi

\subsection{Overview}

This chapter explains in detail how the graph drawing engine works. As
explained in Section~\ref{section-library-graphdrawing}, the graph
drawing engine provides a connection between the syntax of \tikzname\
and \pgfname for specifying graphs and code written in the Lua
programming language for computing layouts. The present section will
discuss this process in detail.

Let us start with the broad picture. The general idea behind the whole
graph drawing engine is that whenever \pgfname\ creates a node, we
intercept this node creation and \emph{do not} immediately place the
node. Rather, we pass them down to Lua, which tucks away the node in
some internal tables. For edges, we introduce a special command called
|\pgfgdedge| that tells Lua that there is an edge between two
tucked-away nodes. Then, after the graph has been completely
specified, a graph drawing algorithm written in Lua starts to work on
the graph by computing new positions for the nodes. Then, the graph
drawing engine will send back the nodes and edges to \pgfname, which
then finally places them at their final positions.

Note that graph drawing algorithms need no knowledge of how any of
these internals work. Indeed, inside a graph drawing algorithm you get
access to a |graph| object that is an object-oriented model of the
graph. No \TeX\ programming skills are required to design and test a
graph drawing algorithm, only Lua is used here.

Let us now have a look at a simple example to see what happens when a
graph is specified:

\begin{codeexample}[]
\tikz[tree]
  \graph{root [as=Hello] -> World[fill=blue!20]};
\end{codeexample}

The special key |tree| internally calls the macro |\pgfgdbeginscope|,
which starts up the graph drawing engine. Once this macro has been
called, until the next call of |\pgfgdendscope|, all nodes that are
created actually get passed down to the graph drawing engine. This is
implemented on the lowest layer, namely by directly intercepting
nodes freshly created using |\pgfnode|. In our example, this happens
in two places: For the |root| node and for the |World| node. The
|graph| library and \tikzname\ internally call the |\pgfnode| macro
for these two nodes (after a large number of internal syntax
translations, but the graph drawing engine does not care about them).

Note that the node boxes will have been fully created before they are
passed down to the graph drawing engine -- only their final position
is not yet fixed. It is not possible to modify the size of nodes
inside the graph drawing engine. 

In contrast, the single edge of the graph that is created by the |->|
command is not fully created before it is passed down to the
engine. This would not really make sense since before the final
positions of the nodes are fixed, we cannot even begin to compute the
length of this edge, let alone where it should start or end. For this
reason, on the upper \tikzname\ layer, the normal edge creation that
would be caused by |->| via |new ->| is suppressed. Instead, the
command |\pgfgdedge| is called. Similarly, inside a graph drawing
scope, \tikzname\ will suppress both the |edge| and the
|edge from parent| command and cause |\pgfgdedge| to be called
instead. 

An overview of what happens is illustrated by the following call graph:

\begin{tikzpicture}[
    class name/.style={draw,minimum size=20pt, fill=blue!20},
    object node/.style={draw,minimum size=15pt, fill=yellow!20},
    p/.style={->,>=stealth'},
    livespan/.style={thick,double},
    xscale=0.8]
  % class names above
  \node (tikz) at (0,4) [class name] {\tikzname\ layer};
  \node (tex) at (5,4) [class name] {\pgfname\ layer};
  \node (interface) at (10,4) [class name] {Lua: Class Interface};
  \node (sys) at (15,4) [class name] {Lua: Class Sys};
  % lines from the class names to the bottom of the picture
  \draw[livespan] (tikz) -- (0,-7.5);
  \draw[livespan] (tex) -- (5,-7.5);
  \draw[livespan] (interface) -- (10,-7.5);
  \draw[livespan] (sys) -- (15,-7.5);
  % first command: \graph{  -- generates new graph in lua interface
  \node (tikz-begin-graph) at (0,3) [object node] {|\graph[algorithm=...]{|}; %}
  \node (tex-begin-graph) at (5,3) [object node] {|\pgfgdbeginscope|};  
  \node (interface-new-graph) at (10,3) [object node] {|newGraph(|...|)|};
  \draw [p] (tikz-begin-graph.east) -- (tex-begin-graph.west);
  \draw [p] (tex-begin-graph.east) -- (interface-new-graph.west);    
  % second command: a -> b   -- generates two nodes in lua
  % and one edge
  \node (tikz-node) at (0,2) [object node] {|a -> b;|};
  \node (tex-node) at (5,2) [object node] {|\pgfnode|};
  \node (interface-add-node-behind) at (10.1,1.9) [object node] {|addNode(|...|)|};
  \draw[p] (tikz-node.east) -- (tex-node.west);
  
  \node (interface-add-node) at (10,2) [object node] {|addNode(|...|)|};
  \draw[p] (tex-node.east) -- (interface-add-node.west);

  \node (tex-add-edge) at (5,1) [object node] {|\pgfgdedge|};
  \node (interface-add-edge) at (10,1) [object node] {|addEdge(|...|)|};
  \draw[p] (tikz-node.east) -- (1.5,2) -- (1.5,1) -- (tex-add-edge.west);
  \draw[p] (tex-add-edge.east) -- (interface-add-edge.west);

  % scope ends -- cloes graph, layouts it and draws it
  \node (tikz-end) at (0,0) [object node] {|};|};
  \node (tex-end) at (5,0) [object node] {|\pgfgdendscope|};
  \node (interface-draw-graph) at (10,0) [object node] {|drawGraph()|};
  \node (interface-finish-graph) at (10,-2) [object node] {|finishGraph()|};

  \node (invoke-algorithm) at (12.5,-1) [object node] {invoke algorithm};
  \draw[p] (tikz-end.east) -- (tex-end.west);
  \draw[p] (tex-end.east) -- (interface-draw-graph.west);
  \draw[p] (interface-draw-graph.east) -- (12.5,0) -- (invoke-algorithm.north);
  \draw[p] (tex-end.east) -- (7.5,0) -- (7.5,-2) -- (interface-finish-graph.west);

  % begin shipout
  \node (sys-begin-shipout) at (15,-2) [object node] {|beginShipout()|};
  \draw[p] (interface-finish-graph.east) -- (sys-begin-shipout.west);
  \node (tex-begin-shipout) at (5,-3) [object node] {|\pgfgdbeginshipout|};
  \draw[p] (sys-begin-shipout.187) -- (12,-2.2) -- (12,-3) -- (tex-begin-shipout.east);

  % put tex box
  \node (sys-puttexbox-behind) at (15.1,-4.1) [object node] {|putTeXBox(|...|)|};
  \node (sys-puttexbox) at (15,-4) [object node] {|putTeXBox(|...|)|};
  \node (tex-puttexbox) at (5,-4.5) [object node] {|\pgfpositionnodenow|};
  \node (tex-putedge) at (5,-5.5) [object node] {|\pgfgdedgecallback|};

  \draw[p] (12.5,-2) -- (12.5,-4) -- (sys-puttexbox.west);
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-4) -- (sys-puttexbox.west);
  \draw[p] (sys-puttexbox.187) -- ++(-2,0) |- (tex-puttexbox.east);

  % put edge
  \node (sys-put-edge-behind) at (15.1,-5.1) [object node] {|putEdge(|...|)|};
  \node (sys-put-edge) at (15,-5) [object node] {|putEdge(|...|)|};
  \draw[p] (sys-put-edge.187) -- ++(-2,0) |- (tex-putedge.east);
  \draw[p] (12.5,-4) -- (12.5,-5) -- (sys-put-edge.west);
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-5) -- (sys-put-edge.west);
  % end shipout
  \node (sys-end-shipout) at (15,-6.5) [object node] {|endShipout()|};
  \draw[p] (12.5,-5) |- (sys-end-shipout.west);
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-6) -- (sys-end-shipout.west);
  \node (tex-end-shipout) at (5,-7) [object node] {|\pgfgdendshipout|};
  \draw[p] (sys-end-shipout.187) -- ++ (-2,0) |- (tex-end-shipout.east);
\end{tikzpicture}


In Section~\ref{section-gd-scopes} we detail the different commands
needed to communicate with the graph drawing engine. In particular,
the commands for beginning and ending scopes are explained here. The
next section, Section~\ref{section-gd-parameters} explains how graph
parameters are setup and configured, both on the \TeX\ side and on the
Lua side. The remaining sections are dedicated entirely to the Lua
side of the graph drawing engine. We first give an overview and then
detail how new graph drawing algorithms can be implemented. This is
followed by a detailed reference of the avaiable classes and
functions. 



\subsection{Graph Drawing Scopes}
\label{section-gd-scopes}

In order to tell the graph drawing engine that a certain scope
contains nodes that should be send to a graph drawing algorithm, the
following commands are used:

\begin{command}{\pgfgdbeginscope}
  This macro starts a \TeX\ scope. The following things will happen:
  \begin{enumerate}
  \item A new |graph| object is on the top of the Lua graph stack. All
    subsequent operations will work on this graph until
    |\pgfgdendscope| will be called.
  \item Inside the scope, no nodes are placed immediately. Rather, 
    the macro |\pgfpositionnodelater|, see
    Section~\ref{section-shapes-deferred-node-positioning}, is used to
    send all nodes created inside the scope to some internal collector
    macro. This internal collector macro will pass down the created
    node to Lua.
  \item Some additional \meta{code} is executed, which has been set
    using the following command:
    \begin{command}{\pgfgdaddspecificationhook\marg{code}}
      This command adds the \meta{code} to the code that is executed
      whenever a graph drawing scope starts. For instance, the
      \tikzname\ library |graphdrawing| uses this macro to add some
      \meta{code} that will redirect the |edge| and |edge from parent|
      path commands to |\pgfgdedge|.
    \end{command}
  \item |\pgftransformreset| is called. See
    Section~\ref{section-gd-lua-coordinates} for details on the effect
    of this.
  \end{enumerate}
  The above has a number of consequences for what can happen inside a
  graph drawing scope:
  \begin{itemize}
  \item Since no nodes are actually created before the end of the
    scope, you cannot reference these nodes. Thus, you cannot write
\begin{codeexample}[code only]
\tikz [spring layout] {
  \node (a) {a};
  \node (b) {b};
  \draw (a) -- (b);
}
\end{codeexample}
    The problem is that we cannot connect |(a)| and |(b)| via a
    straight line since these nodes do not exist at that point (they
    are available only deeply inside the Lua layer).
  \item In order to create edges between nodes inside a graph drawing
    scope, you need to call the |\pgfgdedge| command, described below.
  \end{itemize}
\end{command}


\begin{command}{\pgfgdendscope}
  This macro is used to end a graph drawing scope. It must be given on
  the same \TeX\ grouping level as the corresponding
  |\pgfgdbeginscope|. When the macro is called, it triggers a lot of
  new calls:
  \begin{enumerate}
  \item The special treatment of newly created boxes is ended. Nodes
    are once more created normally.
  \item The effects of the \meta{code} that was inserted via the
    specification hook command also ends (provided it had no global
    effects).
  \item Then, on the Lua layer, the graph drawing algorithm is
    started. Which algorithm is started depends on the current value
    of the |algorithm| key, see
    Section~\ref{section-gd-implementing-algorithms} for details.
  \item When the algorithm has finished, a so-called \emph{shipout
      phase} is started.
  \item During this phase, all nodes that were intercepted during the
    graph drawing scope get inserted into the output stream at the
    positions that were computed for them. Also, for each edge that
    was requested via |\pgfgdedge|, the macro |\pgfgdedgecallback| is
    called (see below).

    The nodes are positioned \emph{before} the edges are drawn; after
    all, it is hard to draw an edge between nodes when their positions
    are not yet known. However, we typically want the nodes to be
    rendered \emph{after} or rather \emph{on top} of the edges. For
    this reason, the default behaviour is that the nodes at their
    final positions are collected in a box that is inserted into the
    output stream only after the edges have been drawn -- which has
    the effect that the nodes will be placed ``on top'' of the
    edges. This behaviour can be changed using the following keys:
\begin{key}{/graph drawing/nodes behind edges}
  \keyalias{tikz}\keyalias{tikz/graphs}
  When this key is invoked, nodes are placed \emph{behind} the edges:
\begin{codeexample}[]
\tikz \graph [spring layout, nodes={draw,fill=white}, nodes behind edges]
  { subgraph K_n [n=7] };    
\end{codeexample}
  When this key is used, you can still request individual edges to be
  placed \emph{behind} the nodes by putting them on the background
  layer:
\begin{codeexample}[]
\tikz \graph [spring layout, nodes={draw,fill=white}, nodes behind edges]
{ [simple]
  subgraph K_n [n=7];
  2 -> [on background layer, bend right=5] 6;
  4 -> [on background layer, bend right=5] 5;
};    
\end{codeexample}  
  Note, however, that when an edge is placed on the background layer,
  due to technical reasons, many graphic state options like changin
  the color will have no effect.
\end{key}
\begin{key}{/graph drawing/edges behind nodes}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This is the default placemenet of edges: Behind the nodes.
\begin{codeexample}[]
\tikz \graph [spring layout, nodes={draw,fill=white}, edges behind nodes]
  { subgraph K_n [n=7] };    
\end{codeexample}
\end{key}
  \item Finally, the shipout phase is finished, the graph is popped
    from the graphs stack and the \TeX\ scope is ended. 
  \end{enumerate}
\end{command}


As described above, inside a graph drawing scope, nodes are
automatically passed down to the graph drawing engine, while for edges
a command has to be called explicitly:

\begin{command}{\pgfgdedge\marg{first node}\marg{second
      node}\marg{edge direction}\marg{edge options}\marg{aux text}}
  This command is used to tell the graph drawing engine that there is
  an edge between \meta{first node} and \meta{second node} in your
  graph. The ``kind'' of connection is indicated by \meta{direction},
  which may be one of the following:
  \begin{itemize}
  \item 
    |->| indicates a directed edge (also known as an arc) from
    \meta{first node} to \meta{second node}.
  \item |--| indicates an undirected edge between \meta{first node}
    and \meta{second node},
  \item |<-| indicates a directed edge from \meta{second node} to
    \meta{first node}, but with the ``additional hint'' that this is a
    ``backward'' edge. A graph drawing algorithm may  or may not take
    this hint into account.
  \item |<->| indicates a bi-directed edge between \meta{first node}
    and \meta{second node}. 
  \item |-!-| indicates that the edge from \meta{first node} to
    \meta{second node} should be removed prior to processing the
    graph. It does not matter whether the edge to be removed was created
    as a directed edge (with |->|, |<-| or |<->|) or as an undirected
    edge.
  \end{itemize}
  The parameters \meta{edge options} and \meta{aux text} are a bit
  more tricky. When an edge between two vertices of a graph is created
  via |\pgfgdedge|, nothing is actually done immediately. After all,
  without knowing the final positions of the nodes \meta{first node}
  and \meta{second node}, there is no way of creating the actual
  drawing commands for the edge. Thus, the actual drawing of the edge
  is done only when the graph drawing algorithm is done (namely in the
  macro |\pgfgdedgecallback|, see later). 

  Because of this ``delayed'' drawing of edges, options that influence
  the edge must be retained until the moment when the edge is actually
  drawn. Parameters \meta{edge options} and \meta{aux text} store such
  options. 

  Let us start with \meta{edge options}. This parameter should be set
  to a list of key-value pairs like
\begin{codeexample}[code only]
/tikz/.cd, color=red, very thick, this edge must be vertical
\end{codeexample}
  Some of these options may be of interest to the graph drawing
  algorithm (like the last option) while others will 
  only be important during the drawing of edge (like the first
  option). The options that are important for the graph drawing
  algorithm must be passed to the algorithm via setting keys that have
  been declared using the handler |.edge parameter|, see
  Section~\ref{section-gd-parameters}. 

  The tricky part is that options that are of interest to the graph
  drawing algorithm must be executed \emph{before} the algorithm starts,
  but the options as a whole are usually only executed during the
  drawing of the edges, which is \emph{after} the algorithm has finished.
  To overcome this problem, the following happens:

  The options in \meta{edge options} are executed ``tentatively'' inside
  |\pgfgdedge|. However, this execution is done in a ``heavily guarded
  sandbox'' where all effects of the options (like changing the
  color or the line width) do not propagate beyond the sandbox. Only
  the changes of the graph drawing edge parameters leave the
  sandbox. These parameters are then passed down to the graph drawing
  engine.

  Later, when the edge is drawn using |\pgfgdedgecallback|, the
  options \meta{edge options} are available once more and then they
  are executed normally.

  Note that when the options in \meta{edge options} are executed, no
  path is preset. Thus, you typically need to start it with, say,
  |/tikz/.cd|. Also note that the sandbox is not perfect and changing
  global values will have an effect outside the sandbox. Indeed,
  ``putting things in a sandbox'' just means that the options are
  executed inside a \TeX\ scope inside an interrupted path inside a
  \TeX\ box that is thrown away immediately. 
  
  The text in \meta{aux text} is some ``auxilliary'' text that is
  simply stored away and later directly to |\pgfgdedgecallback|. This
  is used for instance by \tikzname\ to store its node labels. 
\end{command}


\begin{command}{\pgfgdsetedgecallback\marg{macro}}
  This command allows you to change the \meta{macro} that gets called
  form inside the graph drawing engine at the end of the creation of a
  graph, when the nodes have been positioned. The \meta{macro} will be 
  called once for each edge with the following parameters:
  \begin{quote}
    \meta{macro}\marg{first node}\marg{second
      node}\marg{direction}\marg{edge options}\marg{aux
      text}\marg{algorithm-generated options}\marg{bend information}
  \end{quote}

  The first five parameters are the original values that were passed
  down to the |\pgfgdedge| command.
  
  The \meta{algorithm-generated options} have been ``computed by the
  algorithm''. For instance, an algorithm might have determined, say,
  flow capacities for edges and it might now wish to communicate this
  information back to the upper layers. These options should be
  executed with the path |/graph drawing|.
  
  The parameter \meta{bend information} contains
  algorithmically-computed information concerning how the 
  edge should bend. Currently, this will be a text like
  |(10pt,20pt)--(30pt,40pt)| in \tikzname-syntax, but this may change
  to make things more portable.

  The default \meta{macro} simply draws a line between the nodes. When
  the |graphdrawing| library of the \tikzname\ layer is loaded, a more
  fancy \meta{macro} is used that takes all of the parameters into
  account.
\end{command}


\subsection{Parameters}
\label{section-gd-parameters}

When a graph drawing algorithm starts working, a set of options,
called ``graph drawing parameters'' or just ``parameters'' (in
constrast to ``options'') in the following, can influence
the way the algorithm works. For instance, a graph drawing parameter
might be the average distance between vertices which the algorithm
should take into account. Another example might be the fact the
certain nodes are special nodes and that a certain edge should have
a large label.

These graph drawing parameters are different from ``usual'' \pgfname\
options: An alogrithmic parameter influences the way the algorithm
works, while usual options influence the way the result
looks like. For instance, the fact that a node is red is not a
graph drawing parameter, while the shape of a node might be an graph
drawing parameter. 

Graph parameter should usually be keys with a path starting with
|/graph drawing| (although, strictly speaking, this is not
necessary). The following command makes it a bit easier to set them:
\begin{command}{\pgfgdset\marg{options}}
  Executes the \meta{options} with the path |/graph drawing|.  
\end{command}

There are three kinds of graph drawing parameters:

\begin{itemize}
\item \emph{Graph parameters:}
  These parameters influence ``the whole graph''. An example
  is the distance between vertices on the same level of a tree.
\item \emph{Node parameters:}
  These parameters are ``attached'' to a single node. This includes
  options that are only meaningful in the context of a graph
  drawing algorithm (like, say, the ``mass'' of a node in a
  force-based algorithm), but also hybrid attributed like the shape
  of a node. The shape is important for \pgfname\ when it typesets the 
  node, but it may also be important for the graph drawing
  algorithm since it might position circles differently from, say,
  rectangles.
\item \emph{Edge parameters:}
  Similarly to nodes, edges can also have graph drawing
  parameters. Also similarly to nodes, there can be purely
  graph drawing parameters and also options that are hybrid.
\end{itemize}
   
You have to ``declare'' a graph drawing parameter similarly to a
normal key, but instead of using the |.code| handler, you use
\begin{itemize}
\item |.graph parameter|,
\item |.node parameter|, and
\item |.edge parameter|.
\end{itemize}
More details on how these handlers work is given below.

Specifying the set of graph drawing parameters for a given graph or
node or edge works as follows: When the graph drawing engine is
started for a graph (using |\pgfgdbeginscope|), a snapshot is taken of
all graph drawing graph parameters currently setup at this
point. Similarly, when a node is created inside such a scope (using
|\pgfnode|), a snapshot is taken of the set of all graph drawing node
parameters in force at this point is taken and stored together with
the node. Finally, when an edge is created (using |\pgfgdedge|), a
snapshot of the setting of the graph drawing edge parameters is
taken. 

All of these option sets can easily be accessed inside the graph 
drawing algorithms.



\subsubsection{Basic Commands For Setting Parameters}

Let us start with the basic commands for setting a graph parameter
(you will not call these commands directly, in general).

\begin{command}{\pgfgdgraphparameter\marg{graph
      parameter}\marg{value}} 
  Sets the \meta{graph parameter} inside the local \TeX\ scope to
  \meta{value}. When |\pgfgdbeginscope| is encountered,
  the current settings of all graph parameters that have been set
  using this command will be passed down to the graph drawing
  engine. (Note that this happens right at the beginning of the graph
  drawing scope.)

  Inside a graph drawing algorithm, you can access to \meta{value} as
  follows:
\begin{codeexample}[code only]
  local myvalue = graph:getOption('<graph parameter>');
\end{codeexample}
  where |<graph parameter>| should be the exact text passed as
  \meta{graph parameter}.

  In case that a graph parameter has not been set, the |getOption|
  function will return |nil| (but see also the description of the
  |.parameter initial| handler below).
\end{command}


\begin{command}{\pgfgdnodeparameter\marg{node
      parameter}\marg{value}} 
  Sets the \meta{node parameter} inside the local \TeX\ scope to
  \meta{value}. Unlike a graph parameter, this command can 
  be called inside a graph drawing scope. When a |\pgfnode| command is
  is encountered, the current settings of all node parameters that
  have been set using this command will be passed down to the graph
  drawing engine and will be stored alongside the node.

  Inside a graph drawing algorithm, you can access to \meta{value} as
  follows:
\begin{codeexample}[code only]
  local myvalue = node:getOption('<node parameter>');
\end{codeexample}
  where |<node parameter>| should be the exact text passed as
  \meta{node parameter}. In case that a graph parameter has not been
  set, the |getOption| function will return |nil|.
\end{command}

\begin{command}{\pgfgdedgeparameter\marg{edge
      parameter}\marg{value}} 
  Works like |\pgfgdnodeparameter|, only for edges. Now, the values
  that have been set when |\pgfgdedge| is called are important. The
  settings can be accessed via 
\begin{codeexample}[code only]
  local myvalue = edge:getOption('<edge parameter>');
\end{codeexample}
\end{command}


\subsubsection{Key Handlers  For Setting Parameters}

In practice, you do not call the above commands directly. Instead, you
use key handlers that will take care of calling these commands
internally.

\begin{handler}{{.graph parameter}|=|\opt{\meta{conversion}}}
  When this key hanlder is applied to a key, this key ``becomes a
  graph drawing graph parameter''. Subsequently, assigning a value to
  the key will cause an appropriate call of |\pgfgdgraphparameter| to
  be issued. For instance, suppose we say
\begin{codeexample}[code only]
\pgfkeys{ /some path/my key/.graph parameter }
\end{codeexample}
  and then subsequently
\begin{codeexample}[code only]
\pgfkeys{ /some path/my key=foo }
...
\pgfgdbeginscope
  ...
\pgfgdendscope
\end{codeexample}
  Then, inside the graph drawing scope, a call to
\begin{codeexample}[code only]
   local myvalue = graph:getOption('/some path/my key')
\end{codeexample}
  will set |myvalue| to |'foo'|.
  
  \medskip
  \noindent\textbf{Conversions.}
  In many cases, when you specify a graph parameter, you will not wish
  the original \meta{value} to be passed to the algorithm. For
  instance, suppose we write 
\begin{codeexample}[code only]
\pgfkeys{ /some path/width/.graph parameter }
\end{codeexample}
  We could now say |/some path/width=20pt+2pt|. Then, inside the 
  algorithm call to the function |getOptions('/some path/width')| would yield the
  string |'20pt+2pt'|. However, inside the algorithm, it would be
  somewhat preferable to have access to the value |22.0| rather than the
  string |'20pt+2pt'|. Similary, when the width is |1in|, the algorithm
  will   prefer to get passed the number |72.27| instead of |'1in'|.

  What we need is a \emph{conversion} of the value passed to the key
  before it is stored as a graph parameter. This is done by setting
  a \meta{conversion} when defining the key as a graph parameter. 
  
  Whenever a \meta{value} is assigned to the \meta{key}, the
  \meta{conversion} will be executed with path prefix
  |/graph drawing/conversions/|. The \meta{conversion} gets passed the
  \meta{value} and should store the ``result'' of the
  conversion in the macro |\pgfgdresult|. The contents of this macro is
  the text that will actually be passed down to the algorithm.

  As an example, let us have a look at a math conversion. This can be
  achieved as follows:
\begin{codeexample}[code only]
\pgfkeys{    
  /graph drawing/conversions/math/.code={
    \pgfmathparse{#1}                % Parse the <value>...
    \let\pgfgdresult\pgfmathresult   % and store the result in \pgfgdresult
  }
}
\end{codeexample}

  The following conversion are available by default:
  \begin{key}{/graph drawing/conversions/evaluate math
      expression=\meta{math expression}}
    Passes \meta{math expression} to |\pgfmathparse|.    
  \end{key}
  \begin{key}{/graph drawing/conversions/coordinate=\meta{coordinate}}
    The \meta{coordinate} should have the form
    |(|\meta{number}|pt,|\meta{number}|pt)|. It is converted to the
    format |{|\meta{number}|}{|\meta{number}|}|.

    When you load the \tikzname\ library |graphdrawing| this
    conversion is overwritten by a more powerful conversion: You can
    then pass any \meta{coordinate} that is understood by
    \tikzname. It will still be converted into the
    pair-of-braced-numbers format.
  \end{key}
  
  \medskip
  \noindent\textbf{Default values.}
  When a graph parameter is not set at all, the call to |getOption|
  inside Lua will return |nil|. For most keys, however, a default
  value should be set, such as, say, |1cm| for a node distance. You
  \emph{cannot} just say |node distance/.initial=1cm| for a graph
  parameter |node distance| as one might expect since graph parameters
  are not normal keys. In principle, you could just say
  |node distance=1cm| in some outer scope to setup a default value for the
  key. However, due to the way graph parameters are implemented, if
  this were done for every graph parameter, huge lists of graph
  parameters would be passed around between \pgfname\ and Lua for each
  graph, even when the parameters are not used at all.

  For this reason, there is a special handler that allows you to setup
  initial values for graph parameters:
  \begin{handler}{{.parameter initial}|=|\meta{value}}
    Use this key handler instead of |.initial| to assign an initial value
    to a graph parameter. What will happen is that on the Lua layer,
    the passed \meta{value} is stored in a special table. Whenever the
    \meta{key} is not explicitly set by the user, the \meta{value}
    will be used.

    The \meta{value} gets passed through the \meta{conversion} of the
    graph parameter before it is stored.

    \emph{Remark:} Since the \meta{value} is passed down and managed
    by Lua, changing the initial value is always ``global.'' In
    particular, the values will not revert at the end of \TeX\
    scope. For this reason, you should use this handler only
    immediately after the key has been defined. Subsequently, a value
    should be assigned directly to the key rather than setting a new
    value using the handler once more.
\begin{codeexample}[code only]
\pgfgdset{
  node distance/.graph parameter=evaluate math expression,
  node distance/.parameter initial=1cm
}
\end{codeexample}
  \end{handler}
\end{handler}

\begin{handler}{{.node parameter}|=|\opt{\meta{conversion}}}
  This key works like |.graph parameter|, only it
  affects node parameters rather than graph parameters.

  \emph{Remark:} In \tikzname, when you write |node [foo=bar] {...}|,
  the option |foo| is executed before |\pgfnode| is called
  internally. This means that if foo is a node parameter the ideal
  place to set it is, indeed, as an option of the node -- which is
  exactly what people expect.
\end{handler}

\begin{handler}{{.edge parameter}|=|\opt{\meta{conversion}}}
  This key works like |.graph parameter|, only it
  affects node parameters rather than graph parameters.

  \emph{Remark:} When |\pgfgdedge| is executed, see also its
  documentation, it will ``tentatively'' execute its options. The only
  purpose of this ``tentative option execution'' is that options that
  are edge parameters get setup before the snapshot of the edge
  options is taken.  
\end{handler}




\subsubsection{Advanced Commands For Setting Parameters}

Graph drawing parameters should have the path
|/graph drawing| for systematic reasons. However, as a user we do not
wish to write things like (which would work):
\begin{codeexample}[code only]
\tikz [/graph drawing/algorithm=my algorithm,
       /graph drawing/my algorithm/foo=bar,  
       /graph drawing/blub=foobar] ...
\end{codeexample}
Rather, we would like to write
\begin{codeexample}[code only]
\tikz [my algorithm={foo=bar}, blub=foobar] ...
\end{codeexample}


In order to achieve this and still keep the parameters in the correct
key path, \emph{key forwarding} is used. For most graph parameters, a
key of the same name with the path |/tikz| is setup that will just
forward its value to the corresponding key in the |/graph drawing|
path. Indeed, additionally, another forward is also setup from a key
of the same name with the path |/tikz/graphs|. You could, in
principle, even add new paths for which such forwards are setup.

Note that forwarding often also works when the key with the path
|/tikz| already does something else. In this case, the ``something
else'' will be done first and then the key will forward additionally
to the graph drawing key.

Graph parameters come in too flavours: ``common'' and
``family-specific.'' A ``common'' graph parameter can be used by
several graph drawing algorithms. An example are orientation keys,
which can actually be applied to any graph in a postprocessing
step. In contrast, ``family-specific'' keys are only important for
one algorithm or only for algorithms from a small family of
algorithms. For instance, a ``stiffness'' for spring layout algorithms 
would only apply to, well, spring layout algorithms.

The common graph parameters reside in the path |/graph drawing|,
while the family-specific graph parameters reside in the path
|/graph drawing/|\meta{family name}. For common graph parameters,
forwarding will be setup in paths like |/tikz| or |/tikz/graphs|, so
you can use these keys directly. In contrast, no forwarding will be
setup for family-specific keys. Rather, these keys can be passed to the
algorithm's key, which will in turn executed the keys with the
prefix |/graph drawing/|\meta{family name}.

Since setting up the forwards manually is cumbersome, there are some
special commands that should help you with this. We begin with
commands for setting up common graph parameters, but first we need a
command for specifying the list of paths from which we wish to
forward.

\begin{command}{\pgfgdappendtoforwardinglist\marg{path}}
  Appends the \meta{path} (with trailing slash) to the forwarding
  list. This means that all new keys declared using
  |\pgfgddeclareforwardedkeys| or |\pgfgddeclarealgorithmkey| will
  define a forwarding from a key with the prefix \meta{path} to the
  corrsponding key. 

  If a key has already been defined using one of the command,
  forwarding from \meta{path} will also 
  be setup for this key (using a bit of magic\ldots).  
\end{command}


\begin{command}{\pgfgddeclareforwardedkeys\marg{prefix}\marg{list of key declarations}}
  Each element in the \meta{list of key declarations} should have the
  form \meta{key name}|/|\meta{action}. For each element the following
  keys are setup:

  \begin{itemize}
  \item \meta{prefix}|/|\meta{key name}|/|\meta{actions}
  \item Provided that \meta{prefix}|/|\meta{keyname} was just defined
    for the first time just now, for each \meta{path} in the current
    forwarding list, a forwarding is added from the key
    \meta{path}|/|\meta{key name} to is \meta{prefix}|/|\meta{keyname}.
  \end{itemize}
  Typically, namely when \tikzname\ is used, the forwarding list is
  set to |/tikz,/tikz/graphs|. This means that you can use the
  \meta{key name} both in the |/tikz| and also in the |/tikz/graphs|
  namespace.
\begin{codeexample}[code only]
\pgfgddeclareforwardedkeys{/graph drawing}{
  node distance/.graph parameter=evaluate math expression,
  node distance/.parameter initial=1cm
}
\end{codeexample}
\end{command}


\begin{command}{\pgfgddeclarealgorithmkey\marg{algorithm  key}\marg{algorithm family}\marg{options}}
  This command will setup the following keys:
  
  \begin{key}{/graph drawing/\meta{algorithm key}=\meta{more options}}
    When this key is executed, the \meta{options} that were passed to
    the |\pgfgddeclarealgorithmkey| command are executed first with
    the path prefix |/graph drawing|. Next, the \meta{more options}
    are executed, but now with the path prefix
    |/graph drawing/|\meta{algorithm family}.

    Then, the following key is executed:
    \begin{key}{/graph drawing/at begin scope}
      This key does nothing by default, but it could be used to setup
      things (as is done in \tikzname) to start the graph drawing
      engine for the current scope. 
    \end{key}
  \end{key}

  Next, forwaring is setup from \meta{algorithm key} for all paths in
  the path list to |/graph drawing/|\meta{algorithm key}.
  
  The idea behind the \meta{algorithm family} is that several
  algorithms might share some keys. For
  instance, all spring-based algorithms are defined with the path
  prefix |/graph drawing/spring layout|. For them, the
  \meta{algorithm family} is set to |spring layout|.
\begin{codeexample}[code only]
\pgfgddeclarealgorithmkey
  {Walshaw2000 spring electrical}
  {spring layout}
  {
    algorithm=Walshaw2000 spring,
    spring layout/temperature=0.95,
    spring layout/spring constant=0.01,
  }    
\end{codeexample}
\end{command}  




\subsection{Lua Layer: Overview}

All of the graph drawing engine resides in the directory
|graphdrawing| of |pgf|. Inside, there are the following
subdirectories:

\begin{itemize}
\item |core|, with the subdirectories |lualayer|, |basiclayer|, and |tikzlayer|.
\item |algorithms|, with subdirectories for different kinds of graph
  drawing algorithms.
\end{itemize}

Since most of the graph drawing engine is written in Lua, Most of
these directories contain only Lua code. Indeed, |core/basiclayer|
just contains the \pgfname\ library |graphdrawing|, which implements
the functionalities explained earlier in this section, and
|core/tikzlayer| contains just the \tikzname\ library |graphdrawing|,
which is about a single page of code. By far the largest part of the
graph drawing library resides in the |core/lualayer| directory, where
the supporting classes and files of the graph drawing engines are
gathered.

The |algorithms| directory contains subdirectories for the different
kinds of graph drawing algorithms. For instance, the |tree|
subdirectory contains tree drawing algorithms and so on. Since graph
drawing algorithms are implemented in Lua, these directories also
contain mainly Lua files, which start with |pgfgd-algorithm-|, but
they also contain a library file like the \pgfname\ library
|graphdrawing.tree|. The job of this library is to make the graph
parameters of the algorithms visible to \pgfname, so this file
typically just contains calls of |\pgfgddeclarealgorithmkey| and
|\pgfgddeclareforwardedkeys|.

In the following, we first describe which steps are necessary to
implement a new graph drawing algorithm. We then have a look at the
classes made available to graph drawing algorithms by the
engine. Finally, the section concludes with a class and function
reference.



\subsection{Lua Layer: Installing  Graph Drawing Algorithms}
\label{section-gd-implementing-algorithms}

In the following we describe in detail how a new graph drawing
algorithm can be implemented and installed. 


\subsubsection{Starting the Graph Drawing Engine}

First, before any graph drawing algorithms can be used, the graph
drawing engine needs to be loaded. This is done by loading the
\pgfname\ library |pgflibrarygraphdrawing.code.tex|. This will
initialises the Lua graph drawing subsystem by invoking the Lua loader
class.   

In the most basic cases, no further \TeX\ code needs to be written to
use a new graph drawing algorithm; but we will see later on, that a
small entry in an appropriate \pgfname\ library of graph drawing
algorithms will make the use of the algorithm somewhat simpler.\


\subsubsection{Main File of the Graph Drawing Algorithm}

As explained for the |algorithm| key on
page~\ref{section-gd-algorithm-key}, each graph drawing algorithm  
must be placed in a Lua function called
|drawGraphAlgorithm_|\meta{algorithm name}, with spaces and the |-|
character replaced by underscores, inside the |pgf.graphdrawing| Lua 
module. This function, in turn, should typically be placed in a file 
called |pgfgd-algorithm-|\meta{algorithm name}, again with spaces and
|-| replaced by underscores. ``Typically'' means that it is only
important that the function is already defined when the engine
tries to invoke it or, when this is not the case, the file with the
described name contains this function. You could also put several
algorithms in a single file, but then you must ensure that loading of
the file yourself.

The function |drawGraphAlgorithm_|\meta{algorithm name} will be called
during |\pgfgdendscope|. The function gets an object
representing the graph as its single argument. 


\subsubsection{Coordinate Systems in Lua}

\label{section-gd-lua-coordinates}

The main job of a graph drawing algorithm is to modify the
coordinates of the nodes of the graph object that it gets passed as
its argument. Before we have a look at how this can be done, let us
first clarify how the different coordinate systems of \pgfname\
interact with the graph drawing engine.

Let us start with the case that there is no special transformation
matrix setup is setup. In this case, all coordinates inside the Lua
layer are pairs of numbers that will be interpreted as dimensions in
\TeX\ points (one \TeX\ point equals 1/72.27 inches). The first number
will be interpreted as the $x$-coordinate (going right) and the second
number will be interpreted as the $y$-coordinate (going up). This is
true both for the bounding boxes of the nodes that are passed down to
the Lua layer, but also also for the coordinates that are computed by
the algorithms inside the Lua layer.

When graph parameters are set using the |evaluate math expression|
syntax, the dimensions will already have been converted into this
coordinate system. For instance, when a user writes
|node distance=1in|, then |getOption('/graph drawing/node distance')|
will yield the string |'72.27'|.

Let us now have a look at what happens when a transformation matrix is
set, such as a shift by 1cm to the right and a rotation by
30$^\circ$. In this case, the following happens: At the beginning of a
graph drawing scope, the transformation matrix is reset. Thus, for
instance all nodes created inside the graph drawing scope for which no
scaling or shifting is setup will be centered on the origin. When
|\pgfgdendscope| is reached, the transformation matrix is immediately
restored, \emph{prior} to inserting the nodes at the computed
positions. This means, in particular, that the coordinates computed by
the graph drawing algorithms will be transformed by the transformation
matrix that was in force at the beginning of the graph drawing
scope. Continuing the example, all coordinates computed by the graph
drawing algorithms would be shifted by 1cm and then rotated by
30$^\circ$.

The bottom line is that graph drawing algorithms do not need to worry
about \pgfname's transformation matrix.





\subsubsection{Example of a Graph Drawing Algorithm's Code}

For example, the following code fragment (taken and slightly altered
from the file |pgfgd-algorithm-simple-demo.lua|)
implements a trivial graph drawing algorithm that just places all
nodes on a fixed-size circle.  

\pgfgddeclareforwardedkeys{/graph drawing}{
  radius/.graph parameter=evaluate math expression
}
\pgfgdset{radius/.parameter initial=1cm}


\begin{codeexample}[code only]
-- File pgfgd-algorithm-simple-demo.lua
  
pgf.module("pgf.graphdrawing")

--- A trivial node placing algorithm for demonstration purposes.
-- All nodes are positioned on a fixed-size circle.
function drawGraphAlgorithm_simple_demo(graph)
   local radius = 28.908  -- corresponds to 1cm in TeX points

   -- count nodes
   local nodeCount = table.count_pairs(graph.nodes)

   local alpha = (2 * math.pi) / nodeCount
   local i = 0
   for node in table.value_iter(graph.nodes) do
      -- the interesting part...
      node.pos:set{x = radius * math.cos(i * alpha)}
      node.pos:set{y = radius * math.sin(i * alpha)}
      i = i + 1
   end
end
\end{codeexample}

The algorithm computes a circular layout like in the following:

\begin{codeexample}[]
\tikz [graph drawing scope, /graph drawing/algorithm=simple demo]
  \graph { f -> c -> e ->[bend right] a -> {b -> {c, d, f}, e -> b}};
\end{codeexample}


\subsubsection{Setting Up a Key for Selecting the Algorithm}

Users will typically wish to write something shorter than
|graph drawing scope...| in order to run a graph drawing algorithm on
a graph. For this reason, you should setup a style on the \TeX\ side
that calls the above keys. For instance, you could create a small
\tikzname\ library and place the following in the library:

\begin{codeexample}[code only]
\tikzset{circular layout/.style={
    graph drawing scope,
    /graph drawing/algorithm=simple demo}}
\end{codeexample}

However, there is a better command for this:

\begin{codeexample}[code only]
% Place this in a file like pgflibrarygraphdrawing.circular.code.tex
\pgfgddeclarealgorithmkey
{circular layout}
{circular layout}
{algorithm=simple demo}
\end{codeexample}
\pgfgddeclarealgorithmkey
{circular layout}
{circular layout}
{algorithm=simple demo}

The |\pgfgddeclarealgorithmkey| takes care of setting up your style
key in appropriate ways (including some ways you will not have thought
of) and installs some additional handlers.

\subsubsection{Setting Up Graph Parameters}

Returning to the algorithm, it would be better if we could
``configure'' the radius of the circle. The graph drawing engine
provides for this case: You can declare certain \pgfname\ keys to be
so-called ``graph parameters''. When a key is declared as a graph
parameter, it will be available inside the algorithm: 

\begin{codeexample}[code only]
local radius = tonumber(graph:getOption("/graph drawing/radius"))
\end{codeexample}

Using the |getOption| method we obtain the value of the
graph parameter, but we must first register the key on the \TeX\ side
as follows: 

\begin{codeexample}[code only]
\pgfgddeclareforwardedkeys{/graph drawing}{
  radius/.graph parameter=evaluate math expression,
  radius/.parameter initial=1cm
}
\end{codeexample}

The |evaluate math expression| tells \TeX\ that whenever you assign
something to the |radius| option, the mathematical expression should
be evaluated and the result should be passed down to the graph drawing
algorithm. For instance, when you write |radius=20pt+3.5pt|, the
algorithm will get the value |23.5| as a result to calling
|getOption|. The |getOption| function will return a |nil| value for
keys that have not been set. While this sometimes is desired
behaviour, in our example we would want the radius to be set to a
default value (1cm in this case) when nothing has been specified. This
is achieved by the second line. The result of the above modifications
can be seen in the following example:

\begin{codeexample}[]
\tikz \graph [circular layout, radius=1.5cm]
  {f -> c -> e ->[bend right] a -> {b -> {c, d, f}, e -> b}};
\end{codeexample}


In addition to graph parameters, we can also have \emph{node
  parameters}. These are setup similarly to |.graph parameter|, but
with |.node parameter| and they are then accessed via the
|node:getOption| function.

As a slightly artificial example, let us introduce a |node radius|
key, which allows us to change the radius of a single node. For this,
we check for a node whether its radius key is set:

\begin{codeexample}[code only]
-- In pgfgf-algorithm-simple-example.lua:
   for node in table.value_iter(graph.nodes) do
      -- the interesting part...
      local node_radius = tonumber(node:getOption('/graph drawing/node radius')
                                   or radius)
      node.pos:set{x = node_radius * math.cos(i * alpha)}
      node.pos:set{y = node_radius * math.sin(i * alpha)}
      i = i + 1
   end
   
-- In pgflibrarygraphdrawing.circular.code.tex
\pgfgddeclareforwardedkeys{/graph drawing}{
  node radius/.node parameter=evaluate math expression
}
\end{codeexample}
\pgfgddeclareforwardedkeys{/graph drawing}{
  node radius/.node parameter=evaluate math expression
}

\begin{codeexample}[]
\tikz \graph [circular layout]
  { a -> b -> c -> d [node radius=2cm] -> e -> a };
\end{codeexample}

Here is the complete code of the final algorithm:
\begin{codeexample}[code only]
-- File pgfgd-algorithm-simple-demo.lua
pgf.module("pgf.graphdrawing")

function drawGraphAlgorithm_simple_demo(graph)
   local radius = tonumber(graph:getOption("/graph drawing/radius"))
   local nodeCount = table.count_pairs(graph.nodes)

   local alpha = (2 * math.pi) / nodeCount
   local i = 0
   for node in table.value_iter(graph.nodes) do
      -- the interesting part...
      local node_radius = tonumber(node:getOption('/graph drawing/node radius') or radius)
      node.pos:set{x = node_radius * math.cos(i * alpha)}
      node.pos:set{y = node_radius * math.sin(i * alpha)}
      i = i + 1
   end
end  
\end{codeexample}

\begin{codeexample}[code only]
% File pgflibrarygraphdrawing.circular.code.tex
  
\pgfgddeclarealgorithmkey
  {circular layout}
  {circular layout}
  {algorithm=simple demo}

\pgfgddeclareforwardedkeys{/graph drawing}{
  radius/.graph parameter=evaluate math expression,
  radius/.parameter initial=1cm,
  node radius/.node parameter=evaluate math expression
}
\end{codeexample}



\subsection{Lua Layer: The Main Classes}

In the following, details of the different main classes that are
useful for graph drawing algorithms are documented.


\subsubsection{The Graph Class}

The class |Graph| is used to represent graphs and contains
references to the nodes and edges stored in a graph.

A graph drawing algorithm gets passed a |Graph| object that represents
the to-be-layouted graph. However, you can also create new graph
objects, for instance to decompose the graph into connected
components. 

To create a new graph, you can use the |copy| method, which creates a 
shallow copy (without coying nodes or edges), and the
|subGraphParent| method, which creates a deep copy of the graph, edge
and node objects starting at a designated parent node. If you need
more control by supplying your own set of already visited nodes, use
the underlying function |subGraph|.

A graph allows you to add and remove nodes and edges via |addNode|,
|addEdge|, |removeNode| and |removeEdge| respectively.  There are also
variants which remove all incident edges on a node removal and
conversely, |deleteNode| and |deleteEdge|.

Nodes can be looked up by name with |findNode|. The more generic
|findNodeIf| allows you to search for a node passing a test
predicate. 

The |walkDepth| and |walkBreadth| methods may be used to get
iterators over all nodes and edges in a depth-first or breadth-first
order (other traversal orders may require a rewrite or extension of the
|walkAux| method).

Positions are represented using the dedicated class |Position|, the member
variables |x| and |y| contain the coordinates.  Positions can also be
relative to other positions, which can be tested using |isAbsPosition|.
The conversion to absolute coordinates is done with |getAbsCoordinates|.
The equality test method implements comparing two positions by using their
absolute positions.

The following tasks are typical for manipulating the graph.

\begin{itemize}
\item Iterate over all nodes.
\begin{codeexample}[code only]
for node in table.value_iter(graph.nodes) do
   ...
end
\end{codeexample}
\item Get width or height of a node:
\begin{codeexample}[code only]
local width, height = node.width, node.height
\end{codeexample}
\item Get or set the coordinates of a node. The final values of these
  coordinates will be used during as the actual positions of the nodes
  on the page.
\begin{codeexample}[code only]
node.pos:set{x = node.pos:x() + 1}
node.pos:set{y = node.pos:y() + 1}
\end{codeexample}
\item Relate the position of node to the position of another.
\begin{codeexample}[code only]
newNode.pos:set{x = 1, y = 1}
--sets position of newNode 1 pt in y- and x-direction relative to node
newNode.pos:setOrigin(node.pos)
\end{codeexample}
\item Iterate over all edges and all nodes of the current edge.
\begin{codeexample}[code only]
for edge in table.value_iter(graph.edges) do
   for node in table.value_iter(edge.nodes) do
      ...
   end
end
\end{codeexample}
\item Get the nodes connected by an edge.
\begin{codeexample}[code only]
local nodeLeft = edge.nodes[1]
local nodeRight = edge.nodes[2]
\end{codeexample}
\end{itemize}

\input{generated/pgflibrarygraphdrawing-graph}

The following module simplifies the traversal of graphs:

\input{generated/pgflibrarygraphdrawing-traversal-helpers}


\subsubsection{Nodes and their Boxes}

Nodes serve as direct representations of the \TeX\ level nodes and
include information about incident edges, the calculated position and
the \TeX\ box used.  Typically one'll use its methods to navigate
through the graph or to add and remove edges in an intermediary graph.
Using the information from the \TeX\ side, this class is also able to
provide layout information, i.e. the dimensions of the corresponding
\TeX\ box.

\input{generated/pgflibrarygraphdrawing-node}
\input{generated/pgflibrarygraphdrawing-box}


\subsubsection{The Edge Class}

|Edge| objects contain references to incident nodes, including the
possibility to create hyperedges with more than two nodes for an edge.
Edges can be undirected or directed (denoted by the constants
|Edge.UNDIRECTED| or |Edge.LEFT|, |Edge.RIGHT|, |Edge.BOTH| and
|Edge.NONE| for invisible edges, see |Interface:drawEdge|). 

\input{generated/pgflibrarygraphdrawing-edge}


\subsubsection{Positions and Vectors}

TT: More documentation is needed here!

\input{generated/pgflibrarygraphdrawing-position}
\input{generated/pgflibrarygraphdrawing-vector}


\subsubsection{The Interface and System Classes}

The class |Interface| is the main entry point in Lua. Every
communication from \TeX\ to Lua is done here. It provides methods to
create graphs, add nodes and edges to graphs, and finally to invoke the
selected algorithm. The |Interface| class manages the stack of
graphs. When the |newGraph()| function is called, it generates a new graph
object and pushes it on the graph stack. The methods |addNode()| and
|addEdge()| are called for each node and each edge, creating the
actual Lua objects and adding them to the current graph. 

After adding nodes and edges, when the scope ends, the interface
invokes the actual algorithm to layout the graph. This is done in the
|drawGraph()| function. The next step is to put the nodes back in the
\TeX\ output stream. This is invoked by the |finishGraph()| method. 

\input{generated/pgflibrarygraphdrawing-interface}

Communication with \TeX\ on a basic layer is done in the |Sys|
class. The |beginShipout()| function opens a new scope in \pgfname\
to put all graph drawing nodes into. This prevents other graph objects
outside the graph drawing scope from referencing these nodes. The
|endShipout()| method closes the scope. Nodes and edges are put in the
output stream by the methods |putTeXBox()| and |putEdge()|, which
invoke callbacks to \TeX. 


\subsubsection{Support Classes and Functions}

Most classes in the framework (including the module objects) implement
the |__tostring| method, meaning that you can get a somewhat useful
string representation of the object via the standard |tostring|
function.

\input{generated/pgflibrarygraphdrawing-helper}
\input{generated/pgflibrarygraphdrawing-table-helpers}
\input{generated/pgflibrarygraphdrawing-iter-helpers}




\subsection{Lua Layer: The Module System}
  
The graph drawing engine defines its own Lua module system, which is
characterised by a more dynamic view on importing symbols.  Basically,
each module has a set of imported modules and the lookup for names
first happens in the local scope, then in the current module and
subsequently in all imported modules.  Since no name is statically
imported, newly assigned variables in other modules are still visible
when those were previously imported.

Modules are accessed with the |pgf.module| call, which enables the
module for the current context, that is, the current file. If a module
does not exist, it will be created.  Importing modules is done via
|pgf.import|.  Both functions accept a string argument for the
module name.

Modules are named hierarchically and defined modules are exported into
each parent module.  If the module name contains no period, it is
exported into the global environment.  Nevertheless, importing is only
done on request; importing a module twice does not do anything.
It is recommended to dedicate a single module definition file
to create it and import other modules.  For example, the graph drawing
engine contains a single file containing only the following two lines for
creating the |pgf.graphdrawing| module in the first place.

\begin{codeexample}[code only]
pgf.module("pgf.graphdrawing")
pgf.import("pgf")
\end{codeexample}

Symbol lookup first happens in the local namespace, then in the
current module and subsequently in all imported modules and the global
namespace.  Assignment of new variables happens in the current module
(or for variables declared |local| in the local namespace).  If you
need to assign values to the global environment use the special table
|_G| as you'd normally do in Lua.

The |pgf| module is created during the definition of the module system
and mostly contains functions for loading and debugging.  Developers
probably shouldn't touch the |pgf| namespace and instead add new
functionality to modules below this level or in new top-level
modules.

Let us see what consequences this module system has in practice.  The
following code fragment starts from a clean state after rendering it
with \LuaTeX\ and then enters the |pgf.graphdrawing| module,
overwriting the global |pgf| binding and then again reverting this
change.

\begin{codeexample}[code only]
\usetikzlibrary{graphdrawing}

\directlua{
  pgf.graphdrawing.Sys:log("1: pgf is " .. tostring(pgf))
  pgf.graphdrawing.Sys:log("1: graphdrawing is " .. tostring(graphdrawing))
  
  pgf.module("pgf.graphdrawing")
  
  Sys:log("2: pgf is " .. tostring(pgf))
  Sys:log("2: graphdrawing is " .. tostring(graphdrawing))
  
  pgf = 1
  
  Sys:log("3: pgf is " .. tostring(pgf))
  Sys:log("3: graphdrawing is " .. tostring(graphdrawing))
  
  pgf = nil
  
  Sys:log("4: pgf is " .. tostring(pgf))
  
  pgf.graphdrawing = nil
  
  Sys:log("5: pgf is " .. tostring(pgf))
  
  _G.pgf = nil
  
  Sys:log("6: pgf is " .. tostring(pgf))
}
\end{codeexample}

The result will be as follows:

\begin{codeexample}[code only]
1: pgf is <module 'pgf', table: 0x7979600>
1: graphdrawing is nil

2: pgf is <module 'pgf', table: 0x7979600>
2: graphdrawing is <module 'pgf.graphdrawing', table: 0x7973c60>

3: pgf is 1
3: graphdrawing is <module 'pgf.graphdrawing', table: 0x7973c60>

4: pgf is <module 'pgf', table: 0x7979600>
5: pgf is <module 'pgf', table: 0x7979600>
6: pgf is nil
\end{codeexample}

As you can see, the |pgf| table is available in the global environment
and also after using the |pgf.graphdrawing| module, although we do not 
refer to it with its full name.  Assigning a new value to |pgf|
doesn't overwrite the global object, but introduces a local binding
shadowing the global one. Assigning |nil| then removes the local
binding, therefore in the next line the global variable is available
again.

Note that in all but the first case the binding to |graphdrawing|
stays the same.  Also, using these assignments, you can't accidentally
remove your access to the |pgf| or any imported modules as the last
two assignments show (the |Sys:log| method still works).

Every class and function of the graph drawing engine (except for
module handling in |pgf|) is available in the |pgf.graphdrawing|
module. 


